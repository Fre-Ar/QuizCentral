import { QuizSchema, StyleRegistry, TemplateRegistry } from "@/engine/types/schema";

export type GroupRegistry = Map<string, Group>;

// A viewer is a user who can look at the look but not play (no submission at all)
// A player is a user who takes and potentially submits a quiz (ex: a student)
// An editor is a user who can edit a quiz (if invited, may edit the quiz of the creator at the same time) (ex: a teacher)
// FOR MVP, VIEWER IS NOT SUPPORTED AND THERE CAN ONLY BE ONE EDITOR (the creator)
// FOR MVP, THE BROWSER WILL GUARANTEE THAT ALL GROUPS ALWAYS HAVE PLAYER PERMISSION
export type Permission = 'Viewer' | 'Player' | 'Editor';

// logged-in user
export interface UserAccount {
  googleId: string;
  email: string;
  userName?: string;
  createdAt: string;

  quizzes: { id: string; title: string }[]; // list of (quizName, quizID) creator by User

  styles: StyleRegistry;  // reuseable styles
  templates: TemplateRegistry; // reuseable templates
  groups: GroupRegistry;  // reuseable groups
}

// context when creating
export interface QuizContext {
  // id of the quizSchema extrapolated out of the quizSchema
  // (quizSchemas don't live without a QuizContext 
  // which also ties them to a UserAccount)
  quizId: string; 
  quizCreator: UserAccount; // in the db, quizCreator is an id (foreign key to the userAccounts table)
  quizSchema: QuizSchema; // in the db, quizSchema is stored as a json inside the table of the quizzes

  groups: Group[];
  openSessions: string[]; // ids of the launched sessions, init as empty
  submission: QuizSubmission[]; // init as empty
}

export interface Group {
  id: string; // id can be human readable as it is uniquely identified by its user creator and group id
  name: string; 
  emails: InvitedUser[];
  settings: SessionSettings;
}

export interface SessionSettings {
  acceptSubmissions: boolean;
  openAt: Date|false; // if false, always open
  closeAt: Date|false; // FOR MVP: they are always false, unless the user submits, the session is open.
}

// context when playing
export interface QuizSessionContext {
  sessionId: string; // unique id generated by the app
  user: InvitedUser;
  group: string; // id of the group, references the session settings
  quizCreator: UserAccount; // in the db,this is the googleId of the UserAccount
  quizSchema: QuizSchema; // in the db, this is the id of the quizSchema
  submission?: QuizSubmission; // is filled if 
}

export interface InvitedUser {
  email: string;
  permission: Permission; // permission is either inherited from its group or overriden when defined.
}

// WARNING: THIS IS A VERY EARLY DRAFT, LIKELY TO CHANGE
export interface QuizSubmission {
  // 1. Identity & Context
  sessionId: string; // sessionId of the InvitedUser
  quizCreator: string; // googleId of the userAccount creator
  quizId: string; // id of the quizSchema
  
  // 2. Timing
  startedAt: Date; // metadata, no logic
  submittedAt: Date; // metadata, no logic

  // 3. The Result (What the user claims happened)
  // We send the computed variables so the UI can show immediate feedback,
  // but the server should verify this.
  computedVariables: Record<string, any>; // { "quiz.score": 10, "quiz.passed": true }

  // 4. The Evidence (Raw Inputs)
  // Map of NodeID -> User Value.
  // We DO NOT send computed properties (hidden/disabled), just raw inputs.
  answers: Record<string, any>; 
  
  // 5. Metadata
  triggerSource: "user_click" | "timeout" | "force_quit";
}
